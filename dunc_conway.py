#!/usr/bin/env python3
"""Implementation of the Conway Game of Life.   Successive
states of the cell grid are printed to the terminal window
after clearing the window."""

import argparse
import os
import random
import sys
import time
from argparse import ArgumentParser
from sys import platform

DEFAULT_DEAD_CELL = "  "  # 2 spaces
DEFAULT_LIVE_CELL = " *"  # space and asterisk
DEFAULT_MAX_CYCLES = 200
DEFAULT_SLEEP_TIME = 0.05
DEFAULT_ROWS = 30
DEFAULT_COLS = 30

# Source for color codes:
# https://www.geeksforgeeks.org/print-colors-python-terminal/
COLOR_FOREGROUND = '\033[95m'  # pink
COLOR_BACKGROUND = '\033[40m'  # black
COLOR_RESET = '\033[0m'  # unset colors


def get_default_living(rows, cols):
    """If number of intitial living cells is not specified for the game,
    calculate as a function of grid size."""
    return round((rows * cols) / 4)


# initialize life game from matrix (2d array of 1s and 0s) such as
# [
#    [1,0,1],
#    [0,0,1]
# ]
def life_game_from_matrix(matrix, dead_cell=DEFAULT_DEAD_CELL, live_cell=DEFAULT_LIVE_CELL):
    """Factory method to generate a LifeGame from a 2d matrix.
    A living cell is represented by a 1 in the matrix, a dead cell by a 0.
    Override the default representation of a dead cell (space) or a living cell (asterisk)
    as desired."""
    validate_matrix(matrix)
    rows = len(matrix)
    cols = len(matrix[0])
    alive_count = 0
    life_game = LifeGame(rows, cols)
    life_game.dead_cell = dead_cell
    life_game.live_cell = live_cell
    grid = life_game.get_current_grid()
    for row_index, row in enumerate(matrix):
        for col_index, alive in enumerate(row):
            grid.cells[row_index][col_index].alive = alive
            alive_count += alive
    life_game.alive_count = alive_count
    return life_game


class LifeGame:
    """LifeGame has 2 grids and an index pointing to the current grid.
    The next step of the game is generated by calculating the next state
    (living or dead) of each cell in the current grid and setting that state
    in the corresponding cell of the other grid.  When all cell states
    have been calculated, the index is switched to the other grid
    making it the current grid."""

    def __init__(self, rows, cols, alive_count=0):
        self.grids = []
        self.grids.append(Grid(rows, cols))
        self.grids.append(Grid(rows, cols))
        self.index = 0
        self.dead_cell = DEFAULT_DEAD_CELL
        self.live_cell = DEFAULT_LIVE_CELL
        self.grids[0].set_alive_random_cells(alive_count)
        self.alive_count = self.grids[0].get_alive_count()
        self.string_rep = None
        self.last_string_rep = None  # compare with string_rep to determine static state

    def get_current_grid(self):
        """Return the current grid."""
        return self.grids[self.index]

    def next(self):
        """Use the next state of each cell in the current grid to set the
        cell state in the other grid, then switch the index to other grid
        so that it becomes the current grid."""
        next_index = 1 if (self.index == 0) else 0
        grid = self.get_current_grid()
        next_grid = self.grids[next_index]
        next_alive_count: int = 0  # count of living cells in the next grid
        for row in range(grid.rows):
            for col in range(grid.cols):
                cell = grid.cells[row][col]
                next_cell = next_grid.cells[row][col]
                next_cell.alive = cell.get_next_state()
                next_alive_count += next_cell.alive
        self.index = next_index
        self.alive_count = next_alive_count
        self.last_string_rep = str(self)
        self.string_rep = next_grid.get_as_ascii(self.dead_cell, self.live_cell)

    def get_is_static(self):
        """Return true if the game is no longer changing because all cells are dead
        or the string representation of the current grid is the same as that of
        the last grid."""
        is_static = False
        if self.alive_count == 0:
            is_static = True
        elif self.last_string_rep is not None:
            is_static = str(self) == self.last_string_rep
        return is_static

    def __str__(self):
        if self.string_rep is None:
            self.string_rep = self.get_current_grid().get_as_ascii(self.dead_cell, self.live_cell)
        return self.string_rep


class Grid:
    """Each step of the Game of Life is represented by a 2d Grid of cells."""

    def __init__(self, rows, cols):
        self.rows = rows
        self.cols = cols
        self.cells = [[Cell(self, row, col) for col in range(cols)] for row in range(rows)]

    def get_as_ascii(self, dead_cell_rep, live_cell_rep):
        """Return a string representation of the grid suited for printing to the
        terminal window."""
        ascii_rep = ""
        for row in self.cells:
            for cell in row:
                cell_rep = live_cell_rep if cell.alive == 1 else dead_cell_rep
                ascii_rep += cell_rep
            ascii_rep += os.linesep
        return ascii_rep[:-1]  # trim last linesep before returning

    def get_cell_list(self):
        """Return a list of the cells in the grid.  This method provides a means
        for callers to access all cells in the grid without iterating over the
        rows and columns of the 2d cells array."""
        c_list = []
        for row in self.cells:
            for cell in row:
                c_list.append(cell)
        return c_list

    def set_alive_random_cells(self, alive_count):
        """Set a random selection of alive_count number of cells alive.
        Method intended for use during initialization of the game.  It
        assumes all cells are dead: there is no attempt to clear living
        cells before setting alive_count cells alive."""
        if alive_count > 0:
            cell_list = self.get_cell_list()
            # number of living cells cannot exceed total cells
            actual_alive = min(alive_count, len(cell_list))
            random.shuffle(cell_list)  # get random selection of cells
            for i in range(actual_alive):
                cell_list[i].alive = 1

    def get_alive_count(self):
        """Get the current number of living cells in the grid."""
        return sum(map(lambda cell: cell.alive, self.get_cell_list()))


class Cell:
    """Each cell in the grid is represented by a Cell object which records whether
    the cell is alive (self.alive == 1) ir dead (self.alive == 0).  The Cell has
    a reference to the Grid in which it resides and records its position (row, col)
    in the grid."""

    def __init__(self, grid, row, col):
        self.grid = grid
        self.row = row
        self.col = col
        self.alive = 0

    def get_living_neighbor_count(self):
        """Count and return the (integer) number of living neighboring cells in the grid."""
        living_neighbor_count: int = 0
        for i in range(-1, 2):
            for j in range(-1, 2):
                if i != 0 or j != 0:  # don't use self
                    n_row = self.row + i  # row address of neighboring cell
                    n_col = self.col + j  # col address of neighboring cell
                    if 0 <= n_row < self.grid.rows:  # avoid invalid row index
                        if 0 <= n_col < self.grid.cols:  # avoid invalid col index
                            neighbor = self.grid.cells[n_row][n_col]
                            living_neighbor_count += neighbor.alive
        return living_neighbor_count

    def get_next_state(self):
        """Get the next state of cell (dead or alive) according to the rules of
        Conway's Game of Life.  The next state is a function of the
        current state and the number of living neighboring cells."""
        living_neighbor_count = self.get_living_neighbor_count()
        next_state = 0
        if self.alive == 1:
            if living_neighbor_count < 2:
                # Any live cell with fewer than two live neighbours dies.
                next_state = 0
            elif living_neighbor_count <= 3:
                # Any live cell with two or three live neighbours lives on.
                next_state = 1
            else:
                # Any live cell with more than three live neighbours dies.
                next_state = 0
        elif living_neighbor_count == 3:
            # Any dead cell with exactly three live neighbours becomes a live cell.
            next_state = 1
        return next_state


def validate_matrix(matrix):
    """Check that matrix is 2d array of 1's and 0's.  Expecting input such as
    [
      [1,0,1],
      [0,0,1]
    ]
    The matrix must be implemented as a list of lists, all rows must be
    the same length, and all list members must be 1 or 0."""
    if matrix is None:
        raise ValueError("invalid matrix (matrix not defined)")
    if not isinstance(matrix, list) or not matrix:
        raise ValueError("invalid matrix (expecting list of lists)")
    if not matrix:
        raise ValueError("invalid matrix (expecting list of lists)")

    row_len = None
    for row in matrix:
        if not isinstance(row, list):
            raise ValueError("invalid matrix (expecting list of lists)")
        this_row_len = len(row)
        if row_len is None:
            row_len = this_row_len
        elif row_len != this_row_len:
            raise ValueError("invalid matrix (inconsistent row lengths)")
        for cell in row:
            if cell not in (0, 1):
                raise ValueError("invalid matrix (invalid cell value: expecting 0 or 1)")
    if row_len == 0:
        raise ValueError("invalid matrix (empty columns)")


def __get_clear_command():
    """Get the command line call for the current operating system to clear the terminal window.  If
    the operating system is not detected or if it is determined that the script is not running in
    the terminal window, return None."""
    os_clear_command = None
    if platform == "win32":  # windows
        os_clear_command = "cls"
    elif platform == "darwin":  # mac
        if os.environ.get('TERM') is not None:  # detect if running in terminal window
            # (not in the IDE)
            os_clear_command = "clear"
    elif platform == "linux":
        os_clear_command = "clear"  # assume running in terminal window
    return os_clear_command


def print_state(life_game, cycle_number, max_cycles, os_clear_command=None, step_time=0):
    """Print the current state of the life game grid to the terminal window.
    If the clear command of the operating system has been supplied, use colors
    to print the grid.  If the clear command has been supplied and the time to
    wait between steps (step_time) is greater than 0, wait step_time seconds
    before clearing the window."""
    if os_clear_command is not None:
        if step_time > 0:  # wait before clearing window
            time.sleep(step_time)
        os.system(os_clear_command)

    if max_cycles >= 0:
        print("cycle", cycle_number, ":", max_cycles)
    else:
        print()

    if os_clear_command is not None:  # avoid printing colors in scroll mode
        try:
            print(COLOR_BACKGROUND + COLOR_FOREGROUND + str(life_game))
            print(COLOR_RESET + "alive:", life_game.alive_count)
            print("static:", life_game.get_is_static())
        finally:
            # in case of interrupt,
            # ensure that colors are reset in the terminal window
            print(COLOR_RESET)
    else:
        print(life_game)
        print("alive:", life_game.alive_count)
        print("static:", life_game.get_is_static())
        print()


def main(rows, cols, living, max_cycles, step_time):
    """main subroutine: initialize life game with supplied arguments,
    step through successive states until the cell grid ceases to change
    (life_game.is_static()) or max_cycles is reached.  If max_cycles is negative,
    continue to step through states indefinitely until the cell grid becomes static."""

    # if living negative, calculate as fraction of total cells
    if living < 0:
        living = get_default_living(rows, cols)

    # get operating system command
    # to clear the terminal window
    os_clear = __get_clear_command()

    # initialize the game
    cycle_number: int = 0
    life_game = LifeGame(rows, cols, living)

    # print initial state
    # Note no refresh_time provided: no wait for initial state.
    print_state(life_game, cycle_number, max_cycles, os_clear)

    # step through states of game, printing each state
    while (max_cycles < 0 or cycle_number < max_cycles) and (not life_game.get_is_static()):
        if max_cycles > 0:  # do not increment if not counting so no overflow
            cycle_number += 1
        life_game.next()
        print_state(life_game, cycle_number, max_cycles, os_clear, step_time)


if __name__ == "__main__":
    try:
        # parser code adapted from vishwas_free.py
        parser: ArgumentParser = argparse.ArgumentParser()
        parser.add_argument('-r', '--rows', type=int,
                            help='rows in matrix', default=DEFAULT_ROWS)
        parser.add_argument('-c', '--cols', type=int,
                            help='cols in matrix', default=DEFAULT_COLS)
        parser.add_argument('-l', '--living', type=int,
                            help='initial living cell count', default=-1)
        parser.add_argument('-m', '--max', type=int,
                            help='max cycles, -1 = infinite', default=DEFAULT_MAX_CYCLES)
        parser.add_argument('-t', '--time', type=float,
                            help='time between each cycle in seconds', default=DEFAULT_SLEEP_TIME)

        ARGS = parser.parse_args()
        main(ARGS.rows, ARGS.cols, ARGS.living, ARGS.max, ARGS.time)
    except KeyboardInterrupt:
        print('Interrupted')
        # https://unix.stackexchange.com/questions/251996/why-does-bash-set-exit-status-to-non-zero-on-ctrl-c-or-ctrl-z
        sys.exit(130)
